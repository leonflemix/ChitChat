<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chit Chat AI Discussion App</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Google Fonts (Inter) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles and font definitions */
        :root {
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --background-light: #f9fafb;
            --card-background: #ffffff;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-light);
            min-height: 100vh;
        }
        .container-wrapper {
            max-width: 1000px;
            margin: 0 auto;
        }
        .main-card {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 12px;
        }
        .btn-primary {
            background-color: var(--primary-color);
            transition: background-color 0.2s;
        }
        .btn-primary:hover {
            background-color: var(--primary-hover);
        }
        .area-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .chat-message-ai {
            background-color: #f3f4f6;
            border-radius: 12px 12px 12px 4px;
        }
        .chat-message-user {
            background-color: var(--primary-color);
            color: white;
            border-radius: 12px 12px 4px 12px;
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="container-wrapper">
        <header class="text-center mb-8">
            <h1 class="4xl font-bold text-gray-800">AI Chit Chat & Notes</h1>
            <p id="auth-status" class="text-sm text-gray-500 mt-2"></p>
        </header>

        <!-- API Key Warning/Input -->
        <div id="api-key-setup" class="bg-red-50 border border-red-200 p-4 rounded-lg mb-6">
            <p class="font-semibold text-red-700">⚠️ Gemini API Key Required</p>
            <p class="text-sm text-red-600 mb-2">The AI features require a dedicated **Gemini API Key**. (Your existing Firebase key will not work here).</p>
            <input type="text" id="gemini-api-key-input" placeholder="Paste your Gemini API Key here..." class="w-full p-2 border border-red-300 rounded-lg text-sm">
            <button id="save-api-key" class="mt-2 w-full bg-red-600 text-white p-2 rounded-lg text-sm hover:bg-red-700 transition">Save Key & Reload App</button>
        </div>


        <div id="loading-indicator" class="hidden text-center p-6 bg-yellow-100 text-yellow-800 rounded-lg main-card" role="status">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-yellow-700 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span id="loading-text">Loading...</span>
        </div>

        <div id="app-container" class="main-card bg-white p-6 md:p-8">
            <!-- Content will be injected here (Genre Input, Areas, or Discussion) -->
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // Import Firestore primitives needed for querying recent docs
        import { getFirestore, doc, onSnapshot, collection, query, setDoc, getDoc, getDocs, orderBy, limit, deleteDoc, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ====================================================================
        // CONFIGURATION AND GLOBALS
        // ====================================================================

        // Gemini API Key is stored client-side for immediate functionality.
        // It is RECOMMENDED to use a secure backend proxy in a real deployment.
        let GEMINI_API_KEY = localStorage.getItem('geminiApiKey') || "";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        // The user's provided configuration is used as a fallback if the environment variable is not present.
        const defaultFirebaseConfig = {
            apiKey: "AIzaSyA4ynU2vU6pflZ5wRhD-FxDTh3_cQGiePM",
            authDomain: "chitchat-9264b.firebaseapp.com",
            projectId: "chitchat-9264b",
            storageBucket: "chitchat-9264b.firebasestorage.app",
            messagingSenderId: "233484387798",
            appId: "1:233484387798:web:eb47053333c2e719359077",
            measurementId: "G-31QHY1SD1F"
        };
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : defaultFirebaseConfig;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Set Firebase Log Level
        setLogLevel('debug');

        // Application State
        const appState = {
            db: null,
            auth: null,
            userId: null,
            isAuthReady: false,
            currentView: 'genreInput', // 'genreInput', 'discussion'
            currentGenre: '',
            currentArea: '',
            chatHistory: [], // Stores { role: 'user'/'model', parts: [{ text: '...' }] }
            currentNotes: '',
            discussionId: null,
            recentDiscussions: [],
            hasSuggestions: false, // tracks if the 10 suggestions have been generated
            unsubscribeNotes: null,
        };

        // DOM Elements
        const appContainer = document.getElementById('app-container');
        const loadingIndicator = document.getElementById('loading-indicator');
        const loadingText = document.getElementById('loading-text');
        const authStatusElement = document.getElementById('auth-status');
        const apiKeySetupElement = document.getElementById('api-key-setup');

        // ====================================================================
        // 1. UTILITIES & API CALLS
        // ====================================================================

        /**
         * Generic function to call the Gemini API with exponential backoff.
         */
        async function callGeminiAPI(prompt, systemInstruction, generationConfig = {}, history = []) {
            if (!GEMINI_API_KEY) {
                alertUser("Gemini API Key is missing. Please enter it in the setup box.");
                apiKeySetupElement.classList.remove('hidden');
                throw new Error("API Key missing.");
            }

            loadingIndicator.classList.remove('hidden');
            loadingText.textContent = `Thinking about your request...`;

            // Use the globally available GEMINI_API_KEY
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`;

            // Combine user prompt and chat history
            const contents = [
                ...history,
                { role: "user", parts: [{ text: prompt }] }
            ];

            const payload = {
                contents: contents,
                generationConfig: generationConfig,
                systemInstruction: { parts: [{ text: systemInstruction }] },
            };

            // Conditionally include tools. Tools (like Google Search) are unsupported
            // when requesting structured output (responseMimeType is set).
            if (!generationConfig.responseMimeType) {
                payload.tools = [{ "google_search": {} }];
            }

            let response = null;
            let maxRetries = 5;
            let delay = 1000;

            for (let i = 0; i < maxRetries; i++) {
                try {
                    const fetchResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (fetchResponse.status === 429) { // Rate limit error
                        if (i < maxRetries - 1) {
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                            continue;
                        }
                    }

                    if (!fetchResponse.ok) {
                        const errorMsg = await fetchResponse.text();
                        console.error("API Detailed Error:", errorMsg);
                        
                        if (fetchResponse.status === 403 || fetchResponse.status === 400) {
                            throw new Error(`API call failed: ${fetchResponse.status}. This usually indicates an invalid, expired, or incorrect type of API Key (e.g., using a Firebase key instead of a Gemini Key).`);
                        }
                        throw new Error(`API call failed with status: ${fetchResponse.status}`);
                    }

                    response = await fetchResponse.json();
                    break; // Success
                } catch (error) {
                    console.error("Fetch attempt failed:", error);
                    if (i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                        continue;
                    }
                    throw new Error(error.message || "Failed to connect to the Gemini API after multiple retries.");
                }
            }
            loadingIndicator.classList.add('hidden');

            const candidate = response.candidates?.[0];
            if (!candidate || !candidate.content?.parts?.[0]?.text) {
                throw new Error("Received empty or malformed response from the AI.");
            }

            // For structured JSON, the text part contains the JSON string
            const rawText = candidate.content.parts[0].text;
            
            // Return raw text, letting the caller handle JSON parsing if expected
            return rawText;
        }

        // ====================================================================
        // 2. FIREBASE INITIALIZATION & AUTH
        // ====================================================================

        async function initializeFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                appState.db = getFirestore(app);
                appState.auth = getAuth(app);

                // Sign in using the custom token or anonymously
                if (initialAuthToken) {
                    try { 
                        await signInWithCustomToken(appState.auth, initialAuthToken);
                    } catch (e) {
                         // If custom token fails, fall back to anonymous (likely due to sandbox environment restrictions)
                        if (e.code === 'auth/admin-restricted-operation' || e.code === 'auth/custom-token-mismatch') {
                             console.warn("Custom token sign-in failed. Falling back to anonymous sign-in. Ensure Anonymous Auth is enabled in Firebase Console.");
                             await signInAnonymously(appState.auth);
                        } else {
                            throw e; // Re-throw other critical errors
                        }
                    }
                } else {
                    await signInAnonymously(appState.auth);
                }
                

                // Listen for Auth State Change
                onAuthStateChanged(appState.auth, (user) => {
                    if (user) {
                        appState.userId = user.uid;
                        authStatusElement.innerHTML = `<span class="font-semibold">User ID:</span> ${user.uid} (App: ${appId})`;
                        appState.isAuthReady = true;
                        console.log("Firebase Auth Ready. User ID:", appState.userId);
                        
                        // Call fetchRecentDiscussions here once after authentication is ready
                        fetchRecentDiscussions(); 
                        
                        renderApp(); // Initial render after auth
                    } else {
                        // This handles anonymous fallback
                        appState.userId = crypto.randomUUID(); 
                        appState.isAuthReady = true;
                        authStatusElement.innerHTML = `<span class="font-semibold text-red-500">Anonymous ID:</span> ${appState.userId} (App: ${appId})`;
                        console.log("Firebase Auth Ready (Anonymous Fallback). User ID:", appState.userId);
                        
                        // Call fetchRecentDiscussions here after anonymous auth is ready
                        fetchRecentDiscussions();
                        
                        renderApp();
                    }
                });

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                authStatusElement.innerHTML = `<span class="font-bold text-red-500">Error:</span> Firebase failed to initialize. Check console.`;
            }
        }

        /**
         * Helper to get the Firestore document reference for notes and discussion state.
         */
        function getNotesCollectionRef() {
            if (!appState.db || !appState.userId) return null;
            // Private path: /artifacts/{appId}/users/{userId}/notes_collection
            const path = `artifacts/${appId}/users/${appState.userId}/notes_collection`;
            return collection(appState.db, path);
        }

        function getNotesDocRef(discussionId) {
            if (!discussionId) discussionId = appState.discussionId;
            const colRef = getNotesCollectionRef();
            return colRef ? doc(colRef, discussionId) : null;
        }

        // ====================================================================
        // 3. FIREBASE FIRESTORE (NOTES & HISTORY)
        // ====================================================================

        /**
         * Retrieves the last 5 saved discussions.
         */
        async function fetchRecentDiscussions() {
            if (!appState.isAuthReady || !appState.userId || appState.db === null) return;

            const colRef = getNotesCollectionRef();
            if (!colRef) return;

            try {
                // Query the collection, limit results
                // NOTE: We rely on client-side sorting as orderBy can require indexes
                const q = query(colRef, limit(5)); 
                const snapshot = await getDocs(q);

                // Sort client-side by lastUpdated (descending)
                const discussions = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                
                // Sort in memory by lastUpdated (descending)
                discussions.sort((a, b) => {
                    const dateA = a.lastUpdated ? a.lastUpdated.toDate().getTime() : 0;
                    const dateB = b.lastUpdated ? b.lastUpdated.toDate().getTime() : 0;
                    return dateB - dateA; 
                });

                appState.recentDiscussions = discussions;

                // Only re-render if we are currently on the genre input page 
                if (appState.currentView === 'genreInput') {
                    renderApp(); 
                }
            } catch (e) {
                console.error("Error fetching recent discussions:", e);
            }
        }


        /**
         * Saves the current notes content AND the entire chat history to Firestore.
         */
        async function saveNote(noteText) {
            const notesRef = getNotesDocRef();
            if (!notesRef) {
                console.error("Cannot save note: Missing DB/User/Discussion ID.");
                return;
            }
            
            // Get status element once (FIX: Storing in a variable helps with null check)
            const saveStatusEl = document.getElementById('save-status');

            try {
                // Save chatHistory and noteContent
                await setDoc(notesRef, {
                    noteContent: noteText,
                    chatHistory: appState.chatHistory, // Save the entire chat history
                    lastUpdated: serverTimestamp(),
                    area: appState.currentArea,
                    genre: appState.currentGenre,
                    hasSuggestions: appState.hasSuggestions, // Save suggestion status
                }, { merge: true });
                console.log("Discussion state and notes saved successfully.");
                
                // FIX: Add null check before setting textContent
                if (saveStatusEl) {
                    saveStatusEl.textContent = 'Notes & Chat saved!';
                    setTimeout(() => saveStatusEl.textContent = '', 2000);
                }

                // Trigger a single fetch update to refresh the main page discussion list
                fetchRecentDiscussions(); 
            } catch (e) {
                console.error("Error adding/updating document: ", e);
                // Inform user to check security rules
                alertUser("Error saving notes. Please check your Firestore Security Rules and ensure Anonymous/Authenticated writes are allowed on your path.");
                
                // FIX: Add null check before setting error status
                if (saveStatusEl) {
                     saveStatusEl.textContent = 'Error saving notes.';
                }
            }
        }

        /**
         * Deletes the current discussion document from Firestore.
         */
        async function deleteDiscussion() {
            const notesRef = getNotesDocRef();
            if (!notesRef) {
                alertUser("Cannot delete: No active discussion selected.");
                return;
            }
            
            // Custom confirmation dialog (since alert() is forbidden)
            const confirmed = await confirmAction(`Are you sure you want to permanently delete the discussion on "${appState.currentArea}"? This cannot be undone.`);

            if (!confirmed) {
                return;
            }

            try {
                // Stop listening to the document before deleting it
                if (appState.unsubscribeNotes) {
                    appState.unsubscribeNotes();
                    appState.unsubscribeNotes = null;
                }
                
                // Delete the document
                await deleteDoc(notesRef);
                
                console.log("Discussion deleted successfully.");
                alertUser(`Discussion on "${appState.currentArea}" has been deleted.`);

                // Reset state and return to main screen
                appState.currentView = 'genreInput';
                appState.currentArea = '';
                appState.discussionId = null;
                appState.chatHistory = [];
                appState.currentNotes = '';
                appState.hasSuggestions = false;

                // Update the recent list and render the main view
                fetchRecentDiscussions();
            } catch (e) {
                console.error("Error deleting document:", e);
                alertUser("Error deleting discussion. Check permissions.");
            }
        }


        /**
         * Sets up a real-time listener for the current discussion's notes.
         */
        function setupNotesListener() {
            const notesRef = getNotesDocRef();
            if (!notesRef) return;

            // Stop any existing listener
            if (appState.unsubscribeNotes) {
                appState.unsubscribeNotes();
            }

            appState.unsubscribeNotes = onSnapshot(notesRef, (docSnap) => {
                const notesTextarea = document.getElementById('notes-textarea');
                if (docSnap.exists() && notesTextarea) {
                    // Only update notes content from Firestore in the listener (Chat is loaded in startDiscussion)
                    appState.currentNotes = docSnap.data().noteContent || '';
                    notesTextarea.value = appState.currentNotes;
                    console.log("Notes updated from Firestore.");
                } else if (notesTextarea) {
                    // If document is deleted or doesn't exist yet, reset notes
                    appState.currentNotes = '';
                    notesTextarea.value = '';
                    console.log("Notes document not found, resetting notes.");
                }
            }, (error) => {
                console.error("Error listening to notes:", error);
            });
        }


        // ====================================================================
        // 4. GENERATION LOGIC
        // ====================================================================
        
        /**
         * Generates 10 discussion questions/facts and appends them to the chat history.
         */
        async function generateSuggestions(isNewSet = false) {
            if (!GEMINI_API_KEY) {
                alertUser("Please provide a Gemini API Key to use AI features.");
                return;
            }

            try {
                loadingText.textContent = isNewSet ? `Generating a fresh set of discussion points...` : `Preparing 10 discussion topics...`;
                
                const systemPrompt = "You are a discussion facilitator. Generate exactly 10 unique, thought-provoking questions or interesting facts related to the discussion area. Present them as a numbered list. Be insightful.";
                
                let userPrompt;
                if (isNewSet) {
                    userPrompt = `The current topic is: "${appState.currentArea}". Generate a completely new and distinct set of 10 discussion questions or facts.`;
                } else {
                    // Ask for initial topics/facts
                    userPrompt = `The current topic is: "${appState.currentArea}". Generate 10 discussion questions or facts now.`;
                }
                
                // This call does NOT use structured JSON, so it uses the Google Search tool.
                const responseText = await callGeminiAPI(userPrompt, systemPrompt);
                
                // Append suggestions to chat
                appState.chatHistory.push({ 
                    role: 'model', 
                    parts: [{ text: `--- **Discussion Suggestions for ${appState.currentArea}** ---\n\n${responseText}` }] 
                });
                
                appState.hasSuggestions = true; // Mark as having suggestions

                // Save the chat history immediately
                const notesContent = document.getElementById('notes-textarea') ? document.getElementById('notes-textarea').value : appState.currentNotes;
                await saveNote(notesContent);
                
            } catch (e) {
                alertUser(`Error generating suggestions: ${e.message}`);
            }
            renderDiscussionView();
            document.getElementById('chat-box').scrollTop = document.getElementById('chat-box').scrollHeight;
        }

        /**
         * Starts a new chat or loads a saved discussion based on the genre.
         */
        async function startDiscussion(genre, predefinedDiscussionId = null) {
            appState.currentGenre = genre;
            appState.currentArea = genre; // Use genre as the primary topic/area
            
            // Generate a consistent discussion ID based on the genre (unique for each genre/user combo)
            appState.discussionId = predefinedDiscussionId || appState.currentGenre.replace(/\W/g, '_').toLowerCase().slice(0, 50); 
            appState.hasSuggestions = false; // Reset suggestion status before load

            const notesRef = getNotesDocRef();

            try {
                loadingText.textContent = `Loading discussion for "${genre}"...`;
                
                // 1. Check if discussion already exists (for resuming chat)
                const docSnap = await getDoc(notesRef);
                
                if (docSnap.exists() && docSnap.data().chatHistory) {
                    // Existing discussion found: load saved state
                    const data = docSnap.data();
                    appState.chatHistory = data.chatHistory || [];
                    appState.hasSuggestions = data.hasSuggestions || false; // Load suggestion status
                    appState.currentNotes = data.noteContent || '';
                    console.log("Loaded existing discussion state.");

                } else {
                    // New discussion: start with a simple greeting
                    loadingText.textContent = `Starting a new chat on "${genre}"...`;
                    const systemPrompt = "You are a friendly, concise, and helpful AI chat assistant. Welcome the user to the chat based on their chosen genre. Keep your greeting very short.";
                    const userPrompt = `I want to chat about the genre: "${genre}". Give me a short welcome message.`;
                    
                    const responseText = await callGeminiAPI(userPrompt, systemPrompt);
                    
                    appState.chatHistory = [
                        { role: 'model', parts: [{ text: responseText }] }
                    ];
                    appState.currentNotes = '';
                    appState.hasSuggestions = false;
                    
                    // Immediately save the initial state for future resume
                    await saveNote(''); 
                }
                
                appState.currentView = 'discussion';
                setupNotesListener(); // Start listening for notes
            } catch (e) {
                alertUser(`Error starting discussion: ${e.message}`);
                appState.currentView = 'genreInput'; // Go back to input
            }
            renderApp();
        }

        /**
         * Sends a user message and gets an AI response.
         */
        async function sendChatMessage(userMessage) {
            appState.chatHistory.push({ role: 'user', parts: [{ text: userMessage }] });
            
            // Clear input and immediately render to show user's message
            const chatInput = document.getElementById('chat-input');
            if (chatInput) chatInput.value = '';
            renderDiscussionView();

            try {
                loadingText.textContent = `AI is typing a response...`;
                // NOTE: This call uses the Google Search tool.
                const systemPrompt = `You are an excellent discussion facilitator and AI participant for the area: "${appState.currentArea}". Keep your responses concise, insightful, and friendly. Do not repeat previous points.`;
                const userPrompt = userMessage; // User's message is the prompt

                const responseText = await callGeminiAPI(userPrompt, systemPrompt, {}, appState.chatHistory);

                appState.chatHistory.push({ role: 'model', parts: [{ text: responseText }] });

                // Save chat history after every AI response
                const notesContent = document.getElementById('notes-textarea').value;
                await saveNote(notesContent);

            } catch (e) {
                alertUser(`Error during chat: ${e.message}`);
                // Remove the last user message if AI failed to respond
                appState.chatHistory.pop();
            }
            renderDiscussionView();
            // Scroll to the bottom of the chat box
            document.getElementById('chat-box').scrollTop = document.getElementById('chat-box').scrollHeight;
        }

        // ====================================================================
        // 5. VIEW RENDERING FUNCTIONS & UTILITIES
        // ====================================================================

        /**
         * Renders a generic error or info message to the user.
         */
        function alertUser(message) {
            console.error(message);
            // Simple DOM-based alert instead of alert()
            const alertHtml = `
                <div id="temp-alert" class="fixed top-4 right-4 bg-red-500 text-white p-4 rounded-lg shadow-lg z-50">
                    ${message}
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', alertHtml);
            setTimeout(() => {
                const alertEl = document.getElementById('temp-alert');
                if (alertEl) alertEl.remove();
            }, 5000);
        }
        
        /**
         * Renders a custom confirmation modal. Returns true/false via a Promise.
         */
        function confirmAction(message) {
            return new Promise(resolve => {
                const modalHtml = `
                    <div id="confirm-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 p-4">
                        <div class="bg-white p-6 rounded-lg shadow-2xl max-w-sm w-full">
                            <p class="text-lg font-semibold text-gray-800 mb-4">${message}</p>
                            <div class="flex justify-end space-x-3">
                                <button id="cancel-btn" class="px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition">Cancel</button>
                                <button id="confirm-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">Confirm Delete</button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.insertAdjacentHTML('beforeend', modalHtml);
                const modal = document.getElementById('confirm-modal');

                document.getElementById('confirm-btn').onclick = () => {
                    modal.remove();
                    resolve(true);
                };

                document.getElementById('cancel-btn').onclick = () => {
                    modal.remove();
                    resolve(false);
                };
            });
        }


        /**
         * Renders the Genre Input view, including recent discussions.
         */
        function renderGenreInputView() {
            // Hide/Show API setup based on key presence
            if (GEMINI_API_KEY) {
                apiKeySetupElement.classList.add('hidden');
            } else {
                apiKeySetupElement.classList.remove('hidden');
            }

            appContainer.innerHTML = `
                <div class="p-4 sm:p-6 text-center">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-700">What would you like to discuss?</h2>
                    <p class="mb-6 text-gray-500">Enter a topic or genre (e.g., 'Space Exploration', '1990s Music', 'Greek Mythology').</p>
                    <div class="flex flex-col sm:flex-row gap-4 max-w-lg mx-auto">
                        <input type="text" id="genre-input" placeholder="Enter genre here..." class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-primary-color focus:border-primary-color" required>
                        <button id="submit-genre" class="btn-primary text-white p-3 rounded-lg font-semibold shadow-md hover:shadow-lg transition" ${!GEMINI_API_KEY ? 'disabled' : ''}>
                            Start Chat
                        </button>
                    </div>
                    ${!GEMINI_API_KEY ? '<p class="text-sm text-red-500 mt-3">Please save a Gemini API Key above to enable generation.</p>' : ''}
                </div>

                <section id="recent-discussions-section" class="mt-8 pt-6 border-t border-gray-200">
                    <h3 class="text-xl font-semibold mb-4 text-gray-700">Your Past Discussions (${appState.recentDiscussions.length} recent)</h3>
                    <div id="recent-list" class="space-y-3">
                    ${appState.recentDiscussions.length > 0 ? 
                        appState.recentDiscussions.map(disc => `
                            <div class="recent-discussion-item flex flex-col sm:flex-row justify-between items-start sm:items-center bg-gray-50 p-3 rounded-lg hover:bg-indigo-50 transition border border-gray-100">
                                <span class="font-medium text-gray-800 truncate mb-2 sm:mb-0">
                                    ${disc.genre}
                                    <span class="text-xs text-gray-500 ml-2">(${disc.lastUpdated ? disc.lastUpdated.toDate().toLocaleDateString() : 'N/A'})</span>
                                </span>
                                <button data-id="${disc.id}" data-area="${disc.area}" data-genre="${disc.genre}" class="continue-discussion bg-indigo-200 text-indigo-700 text-xs font-semibold px-3 py-1 rounded-full hover:bg-indigo-300 transition w-full sm:w-auto">
                                    Continue
                                </button>
                            </div>
                        `).join('')
                        : 
                        '<p class="text-gray-500 italic">No past discussions found. Start a new one above!</p>'
                    }
                    </div>
                </section>
            `;

            // Event listener for starting a new chat
            document.getElementById('submit-genre')?.addEventListener('click', () => {
                const genre = document.getElementById('genre-input').value.trim();
                if (genre) {
                    startDiscussion(genre);
                }
            });

            // Event listener for resuming past discussions
            document.querySelectorAll('.continue-discussion').forEach(button => {
                button.addEventListener('click', (e) => {
                    const discussionId = e.target.dataset.id;
                    const genre = e.target.dataset.genre;
                    
                    if (discussionId) {
                        // Pass the genre/area and the discussion ID to load the history
                        startDiscussion(genre, discussionId); 
                    }
                });
            });
        }

        /**
         * Renders the main Discussion and Notes view.
         */
        function renderDiscussionView() {
            appContainer.innerHTML = `
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <!-- Discussion Panel (2/3 width) -->
                    <div class="lg:col-span-2 flex flex-col h-[600px] border border-gray-200 rounded-lg overflow-hidden">
                        <div class="p-4 bg-gray-50 border-b border-gray-200">
                            <div class="flex justify-between items-start mb-4">
                                <button id="back-to-genre" class="text-sm text-primary-color hover:underline flex items-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                                    </svg>
                                    Back to Topics
                                </button>
                                <button id="delete-discussion" class="text-xs px-3 py-1 bg-red-100 text-red-600 rounded-full hover:bg-red-200 transition font-semibold">
                                    Delete Discussion
                                </button>
                            </div>

                            <h3 class="text-xl font-bold text-gray-800 truncate mt-1">Topic: ${appState.currentArea}</h3>
                            
                            <!-- Suggestions Button -->
                            <div class="mt-3">
                                ${!appState.hasSuggestions ? `
                                    <button id="get-suggestions" class="bg-green-600 text-white px-3 py-1 text-sm rounded-lg hover:bg-green-700 transition font-semibold shadow">
                                        Get 10 Discussion Suggestions
                                    </button>
                                ` : `
                                    <button id="get-new-suggestions" class="bg-yellow-500 text-white px-3 py-1 text-sm rounded-lg hover:bg-yellow-600 transition font-semibold shadow">
                                        Generate New 10 Suggestions
                                    </button>
                                `}
                            </div>
                        </div>

                        <!-- Chat Box -->
                        <div id="chat-box" class="flex-grow p-4 space-y-4 overflow-y-auto">
                            ${appState.chatHistory.map(msg => `
                                <div class="flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}">
                                    <div class="${msg.role === 'user' ? 'chat-message-user' : 'chat-message-ai'} max-w-xl p-3 shadow">
                                        <p class="text-sm">${markdownToHtml(msg.parts[0].text, msg.role)}</p>
                                    </div>
                                </div>
                            `).join('')}
                        </div>

                        <!-- Chat Input -->
                        <div class="p-4 border-t border-gray-200 bg-white">
                            <div class="flex gap-2">
                                <input type="text" id="chat-input" placeholder="Type your message..." class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-primary-color focus:border-primary-color" autofocus>
                                <button id="send-chat" class="btn-primary text-white p-3 rounded-lg font-semibold shadow-md hover:shadow-lg transition">
                                    Send
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Notes Panel (1/3 width) -->
                    <div class="lg:col-span-1 flex flex-col h-[600px]">
                        <div class="bg-card-background p-4 border border-gray-200 rounded-lg flex flex-col flex-grow">
                            <h3 class="text-xl font-bold mb-3 text-gray-700">My Notes & Comments</h3>
                            <textarea id="notes-textarea" class="flex-grow p-3 border border-gray-300 rounded-lg resize-none focus:ring-primary-color focus:border-primary-color text-sm" placeholder="Write your thoughts, summaries, or points of interest here...">${appState.currentNotes}</textarea>
                            <div class="flex justify-between items-center mt-3">
                                <button id="save-notes" class="btn-primary text-white px-4 py-2 rounded-lg font-semibold shadow-md hover:shadow-lg transition text-sm">
                                    Save Notes
                                </button>
                                <span id="save-status" class="text-xs text-green-600 font-medium"></span>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Function to handle basic Markdown to HTML conversion for display
            function markdownToHtml(text, role) {
                let html = text;
                
                // Add AI prefix if it's a model response
                if (role === 'model') {
                    html = `<span class="font-bold">AI:</span> ${html}`;
                }

                // Simple bold
                html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                // Simple italic
                html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
                // Line breaks
                html = html.replace(/\n/g, '<br>');
                return html;
            }

            // Event Listeners
            document.getElementById('back-to-genre').addEventListener('click', () => {
                appState.currentView = 'genreInput';
                if (appState.unsubscribeNotes) appState.unsubscribeNotes(); // Clean up listener
                renderApp();
            });
            
            // New: Delete button listener
            document.getElementById('delete-discussion')?.addEventListener('click', deleteDiscussion);

            // New: Suggestions button listeners
            document.getElementById('get-suggestions')?.addEventListener('click', () => {
                generateSuggestions(false);
            });
            document.getElementById('get-new-suggestions')?.addEventListener('click', () => {
                generateSuggestions(true);
            });


            const sendChatButton = document.getElementById('send-chat');
            const chatInput = document.getElementById('chat-input');
            const saveNotesButton = document.getElementById('save-notes');
            const notesTextarea = document.getElementById('notes-textarea');

            const handleSend = () => {
                const message = chatInput.value.trim();
                if (message) {
                    sendChatMessage(message);
                }
            };

            sendChatButton.addEventListener('click', handleSend);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSend();
                }
            });

            saveNotesButton.addEventListener('click', () => {
                saveNote(notesTextarea.value);
            });
            
            // Scroll to bottom when view is rendered
            const chatBox = document.getElementById('chat-box');
            if (chatBox) {
                chatBox.scrollTop = chatBox.scrollHeight;
            }
        }

        /**
         * Main function to render the correct view based on application state.
         */
        function renderApp() {
            if (!appState.isAuthReady) {
                appContainer.innerHTML = '<div class="p-6 text-center text-lg text-gray-600">Initializing Authentication...</div>';
                return;
            }

            switch (appState.currentView) {
                case 'genreInput':
                    renderGenreInputView();
                    break;
                case 'discussion':
                    renderDiscussionView();
                    break;
                default:
                    renderGenreInputView();
            }
        }

        // ====================================================================
        // 6. STARTUP & API KEY HANDLER
        // ====================================================================

        document.getElementById('save-api-key').addEventListener('click', () => {
            const input = document.getElementById('gemini-api-key-input');
            const key = input.value.trim();
            if (key) {
                localStorage.setItem('geminiApiKey', key);
                GEMINI_API_KEY = key;
                // Reload the app to initialize the view with the key
                renderApp(); 
            } else {
                alertUser("Please enter a valid API key.");
            }
        });

        // Initialize the input field with any saved key
        document.getElementById('gemini-api-key-input').value = GEMINI_API_KEY;


        // Start Firebase initialization when the script runs
        initializeFirebase();

    </script>

</body>
</html>